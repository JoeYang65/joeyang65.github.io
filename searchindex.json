{"categories":[{"title":"Development","uri":"https://joeyang65.github.io/categories/development/"},{"title":"Hugo","uri":"https://joeyang65.github.io/categories/hugo/"}],"posts":[{"content":"C# 面对对象的概念 什么叫面对对象，面对对象的概念在这里不多解释了，自行了解去吧。。。\n创建类的对象的过程，就是将类实例化，这个对象就是这个类的实例。\n类是不占内存的，而对象是占内存的。静态类除外\nnull不占内存，不在内存开辟空间，表示无效的、空的。\n重载：一样的方法名，不一样的参数\nthis关键字：   代表当前类的对象\n  在类当中显式的调用本类的构造函数，语法 :this()\n调用的流程是：\n调用类的构造函数B ===\u0026gt; 构造函数B通过:this()调用构造函数A ===\u0026gt; 构造函数A执行完成后返回构造函数B ===\u0026gt; 执行构造函数B内部代码\n  public class Student{ //构造函数创建对象 //第一个构造函数 public Student(string name, int age, char gender, int chinese, int math, int english) { this.Name = name;//this.Name表示当前类的对象的Name属性 this.Age = age; this.Gender = gender; this.Chinese = chinese; this.Math = math; this.English = english; } //第二个构造函数 /* 本构造函数通过this关键字可以本类其他的构造函数，这里调用了第一个构造函数，因为它初始化赋值最全。 调用本构造函数的时候将所需参数传入，然后本构造函数调用第一个构造函数， 同时将本构造函数接收的参数传给第一个构造函数，而本构造函数没有但第一个构造函数需要的参数就传一个具体的值作为默认值。 当本构造函数调用完第一个构造函数之后，又会回到本构造函数，执行本构造函数内部的代码，这里本构造函数内部代码是空的 */ public Student(string name, int chinese, int math, int english):this(name,0,'c',chinese,math,english) { //this.Name = name; //this.Chinese = chinese; //this.Math = math; //this.English = english; } }  new关键字： new帮助我们做了3件事儿：Person person = new Person(); 1、在内存中开辟一块空间 2、在开辟的空间中创建对象 3、调用对象的构造函数进行初始化对象\nnamespace namespace（命名空间），用于解决类的重名问题，可以看作 ”类的文件夹“\n 如果代码和被使用的类在同一个命名空间，就不需要用using引用命名空间 代码和类在不同命名空间下，类的调用有两种方式：  写全称：命名空间.类名 先用using引用命名空间，再调用类   在一个项目中引用另一个项目的类  添加引用，在项目目录下面找到 ”引用“ 文件夹，右键点击添加引用 类中using引用命名空间    值类型和引用类型 区别：\n值类型和引用类型在内存上存储的地方不一样，值类型存储在内存的栈中，引用类型存储在内存的堆中\n在传递值类型和传递引用类型的时候，传递方式不一样。值类型为值传递，引用类型为引用传递。\n值类型：\nint、double、bool、char、decimal、struct、enum\n引用类型：\nstring、自定义类\n类的基本语法 类里面可以写：字段、方法、属性、构造函数\n字段 Field： 用来存数据，命名以“ _ ”开头，如：_name\n方法 Method： 表示类的对象将具有的行为，\n属性 Property： 属性的作用就是保护字段，对字段的赋值和取值进行限制，在将值给到字段之前属性可以通过get和set方法先进行一定的处理。属性的本质就是两个方法，分别是get()和set()\npublic class Person{ //字段 public string _name; //属性，不保存值，就是一个中间商 public string Name{ //取值时调用，返回对应字段的值 get{ //进行一些判断，若满足判断就进行一系列操作，然后才返回字段的值 if(...){ ......//可以写一系列自定义操作 return _name = \u0026quot;xx\u0026quot;;//此处修改了要返回的_name的值 } return _name; } //赋值时调用，通过属性将传入的值value赋值给对应字段 set{ _name = value; } } //方法 public void showPerson(){ //最好当然是通过属性来读取或赋值，属性来和外界打交道，保护里面的字段，将字段的public去掉即可 Console.WriteLine(\u0026quot;my name is {0}\u0026quot;, this.Name); } }  访问修饰符： public：公开的公共的，在哪都能访问\nprivate：私有的，只有当前类的内部可以访问，出了这个类就无法访问\n静态和非静态的区别 在语法上的区别：\n1、在非静态类中，既可以有实例成员（非静态成员），也可以有静态成员，可以实例化；静态类中只允许有静态成员，不能实例化\n2、实例成员需要通过先创建类的对象再通过对象来调用；静态成员直接通过类名来调用\n3、静态函数中，只能访问静态成员，不能访问实例成员；实例方法中却都可以访问\n在使用上区别：\n1、如果将类当作一个”工具类“去使用，使用频率较高，则可以考虑将类写成静态类，使用起来更方便\n2、静态类在整个项目中资源共享，静态类占内存，只有程序全部结束后，静态类才会释放资源\n构造函数 给类创建对象，并给对象的属性赋值，给予对象一些初始的值，将给对象赋值的过程称之为对象的初始化。但一个个属性的去赋值会很麻烦，有很多冗余的代码，因为除了赋的值不一样之外，其余代码都一样。\n构造函数可以帮助我们初始化对象。每个类都有构造方法用来创建对象，并且可以在构造函数中对对象进行初始化，创建对象的时候会执行构造函数。\n 构造函数是用来创建对象的特殊方法，方法名和类名一样，没有返回值，连void也不能写。 如果不指定构造函数，则类有一个默认的无参构造函数。当自己写了一个新的构造函数后，不管有无参数，默认的无参构造函数都没有了 构造函数可以有参数，new对象的时候传递函数参数即可 构造函数可以重载，也就是有多个参数不同的构造函数。  析构函数 当程序结束的时候，析构函数才会执行，帮助我们释放资源。虽然C#里面有GC（Garbage Collection）垃圾回收器，会自动帮我们释放资源，但是如果我们希望马上释放资源的话可以使用析构函数\n//Student是类名，下面的析构函数的写法是固定的 ~Student(){ Console.WriteLine(\u0026quot;我是析构函数\u0026quot;); }  学习到H:\\ProgrammingResource\\ASP.NET资料\\C#和DotNet视频教程\\01.Net基础教程\\01.Net基础\\03-c#高级\\01\u0026ndash;面向对象初级\\video\\3、属性.avi\n 图片资源base64编码：\n","id":0,"section":"posts","summary":"C# 面对对象的概念 什么叫面对对象，面对对象的概念在这里不多解释了，自行了解去吧。。。 创建类的对象的过程，就是将类实例化，这个对象就是这个类的实","tags":["C#"],"title":"C#基础笔记","uri":"https://joeyang65.github.io/2020/05/c-sharp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":"往Markdown里面插入base64图片   基础插入图片语法：\n地址可以是本地地址，支持相对路径或者绝对路径，也可以是网络地址\n  ![描述信息，任意写](图片链接地址)\r  将图片存入markdown文件  通过base64转码工具将图片转成一段字符串，然后将字符串填入到基础格式中链接的位置\n在线转码网站地址：\n例如：base64保存图片的基础写法\n![avatar描述信息](data:image/png;base64,iVBORw0......)\r 但是这样大段的base64字符串影响编写文章的体验，所以可以放在文章末尾，定义一个变量来调用\n如下：base64保存图片的高级写法\n![avatar][base64str]\r[base64str]:data:image/png;base64,iVBORw0......\r ","id":1,"section":"posts","summary":"往Markdown里面插入base64图片 基础插入图片语法： 地址可以是本地地址，支持相对路径或者绝对路径，也可以是网络地址 ![描述信息，任意","tags":["Markdown"],"title":"Markdown插入base64","uri":"https://joeyang65.github.io/2020/05/markdown%E9%87%8C%E9%9D%A2%E6%8F%92%E5%85%A5base64%E5%9B%BE%E7%89%87/","year":"2020"},{"content":"Git的add、commit、push的详细介绍 简单的代码提交流程   git status 查看工作区代码相对于暂存区的差别\n  git add . 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录\n  git commit -m “注释” 将缓存区内容添加到本地仓库\n  git pull origin master先将远程仓库master中的信息同步到本地仓库master中\n  git push -u origin master 将本地版本库推送到远程服务器， origin是远程主机，可以通过下面命令添加远程主机和它的地址：\n$ git remote add origin https://github.com/coderzh/coderzh.github.io.git\n这里push命令的master表示是本地的master分支，分支名是可以修改的，只写一个分支名，那就是推送到origin远程服务器的同名分支上\n  Git add git add [参数] \u0026lt;路径\u0026gt;　作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。 为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。\n git add . 不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除 git add -u . -u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 git add -A . -A 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。  Git commit git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里.\n git commit -m ‘message’ -m 参数表示可以直接输入后面的“message”，如果不加 -m参数，那么是不能直接输入message的，而是会调用一个编辑器一般是vim来让你输入这个message， message即是我们用来简要说明这次提交的语句。 git commit -am ‘message’ -am等同于-a -m -a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区， 注意: 新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。  Git push 在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了，如果不清楚版本库的构成，可以查看我的另一篇，git 仓库的基本结构。 git push的一般形式为 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; \u0026lt;远程分支名\u0026gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。\n git push origin master 如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 git push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master git push origin 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push 如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名  关于 refs/for： refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要\n","id":2,"section":"posts","summary":"Git的add、commit、push的详细介绍 简单的代码提交流程 git status 查看工作区代码相对于暂存区的差别 git add . 将当前目录下修改的所有代码从工作","tags":["Git"],"title":"Git的add、commit、push的详细介绍","uri":"https://joeyang65.github.io/2020/04/git%E7%9A%84addcommitpush%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","year":"2020"},{"content":"Hugo中文文档 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n快速开始 安装Hugo 1. 二进制安装（推荐：简单、快速、跨平台） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）\nMac下直接使用 Homebrew 安装：\nbrew install hugo\r 2. 源码安装 源码编译安装，首先安装好依赖的工具：\n Git Mercurial Go 1.3+ (Go 1.4+ on Windows)  设置好 GOPATH 环境变量，获取源码并编译：\n$ export GOPATH=$HOME/go\r$ go get -v github.com/spf13/hugo\r 源码会下载到 $GOPATH/src 目录，二进制在 $GOPATH/bin/\n如果需要更新所有Hugo的依赖库，增加 -u 参数：\n$ go get -u -v github.com/spf13/hugo\r 生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/sites 路径：\n$ hugo new site /path/to/sites\r 这样就在 /path/to/sites 目录里生成了初始站点，进去目录：\n$ cd /path/to/sites\r 站点目录结构：\n ▸ archetypes/\r▸ content/\r▸ layouts/\r▸ static/\rconfig.toml\r 创建文章 创建一个 about 页面：\n$ hugo new about.md\r about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n+++\rdate = \u0026quot;2015-10-25T08:36:54-07:00\u0026quot;\rdraft = true\rtitle = \u0026quot;about\u0026quot;\r+++\r正文内容\r 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n$ hugo new posts/first.md\r 打开编辑 posts/first.md ：\n---\rdate: \u0026quot;2015-10-25T08:36:54-07:00\u0026quot;\rtitle: \u0026quot;first\u0026quot;\r---\r### Hello Hugo\r1. aaa\r1. bbb\r1. ccc\r 安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来，也可以自己下载好主题文件夹的zip解压并重命名后放入themes目录，再将主题文件里面的exampleSite里面的config.toml复制到站点根目录替换原来的配置文件（注意config不一定是.toml文件格式，具体看主题作者的说明：\n# 创建 themes 目录\r$ cd themes\r$ git clone https://github.com/spf13/hyde.git\r 运行Hugo 在你的站点根目录执行 Hugo 命令进行调试：\n$ hugo server --theme=hyde --buildDrafts\r （注明：v0.15 版本之后，不再需要使用 --watch 参数了）\n浏览器里打开： http://localhost:1313\n部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io （coderzh替换为你的github用户名）。\n在站点根目录执行 Hugo 命令生成最终页面：\n$ hugo --theme=hyde --baseUrl=\u0026quot;https://coderzh.github.io/\u0026quot;\r （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 或者改成draft=false再重新生成。）\n如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。\n$ cd public\r$ git init\r$ git remote add origin https://github.com/coderzh/coderzh.github.io.git\r$ git add -A\r$ git commit -m \u0026quot;first commit\u0026quot;\r$ git push -u origin master\r 浏览器里访问：http://coderzh.github.io/\n后续发布新内容 可以通过hugo命令新建博客帖子的markdown文件 - (文件名为 **.md )，也可以自己写好后放入站点目录里面的content/posts目录里面，注意自己写的要根据Hugo生成的md文件更改开头配置！！！，建议用Hugo生成，这样格式和时间都自动生成好了，文章内容可以自己复制过来。\nhugo new posts/newBlog.md\r 生成静态html页面，\u0026ndash;theme主题写自己使用的主题目录名称\nhugo --theme=blackburn --buildDrafts --baseUrl=“https://coderzh.github.io/”\r 发布网页，注意是发布public目录里面的html文件到GitHub\ncd public\rgit add .\rgit commit -m “new blog added”\rgit push origin master\r Git命令问题 错误1：\ngit remote add origin**************\rfatal: remote origin already exists.（报错远程起源已经存在。）\r 解决1：\n1、先输入 git remote rm origin\r2、再输入 git remote add origin**************\r 错误2：\ngit remote add origin******\rThe authenticity of host 'github.com ' can't be established（无法建立主机“github.com”的真实性）\r 解决2：这是由于你的git地址采用了ssh方式，切换为https方式即可，也可能是你的仓库地址不对，可以用命令先查看一下：\ngit remote -v\r 如果跟你的github地址不一样，那就去你的github上复制一下仓库地址 然后在终端中输入：\ngit remote set-url origin https://github.com/yourname/learngit.git (这个是你的复制的仓库地址)\r 最后再push下就可以了！\ngit push origin master  ","id":3,"section":"posts","summary":"Hugo中文文档 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 快速开始 安装Hugo 1. 二进制安装（推荐：简单、","tags":[""],"title":"Hugo中文文档","uri":"https://joeyang65.github.io/2020/04/hugo%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/","year":"2020"},{"content":"ASP.NET MVC笔记 关于asp.net基础的笔记，对应3个demo，demo里面也有注释，分别是MvcDemo1，MvcDemo2，MvcDemo3\nHttp的内置对象： （对应项目例子名称-MvcDemo1，项目启动后可通过Home/xxx访问action，Post请求用到的html页面叫HtmlPage1，直接选中后右键浏览器打开，修改C#代码后需要生成解决方案后才能生效。）\n   Http对象 解释说明 / 用例一 解释说明 /用例二 解释说明 /用例三     Request请求 服务器接收客户端数据 get请求：Request.QueryString post请求：Request.Form   Response响应 Response.Write向客户端输出内容 重定向：Response.Redirect 响应头：Response.Headers   Session会话 数据保存在服务器中，存储少量重要数据比如账号信息 Session是一个键值对（key - value） 1、安全性比cookie强2、但占用服务器内存，在内存一定的情况下，每个用户数据占用空间越大则服务器能并发的人越少   Cookie客户端数据 添加Cookie：Cookies.Add(new HttpCookie(\u0026ldquo;token\u0026rdquo;){ }) 查看Cookie值：Cookies[\u0026ldquo;token\u0026rdquo;].Value 清除cookie值。通过使cookie过期的方式让浏览器（客户端）清除：Response.Cookies.Add(new HttpCookie(\u0026ldquo;token\u0026rdquo;){Expires = DateTime.Now.AddDays(-1)});   Application当前网站对象 是整个项目（网站）共有的数据，每个用户都能访问 HttpContext.Application[\u0026ldquo;user\u0026rdquo;] = \u0026ldquo;123\u0026rdquo;; Content(HttpContext.Application[\u0026ldquo;user\u0026rdquo;].ToString());   Server服务器对象 Transfer转发： 路径不变，内容变化，只能转发站内的内容重定向： 路径改变，内容没有限制 Server.Transfer(\u0026ldquo;~/xxx.aspx\u0026rdquo;); Response.Redirect(\u0026ldquo;http://www.baidu.com\u0026rdquo;);    控制器和视图之间数据传递 （对应项目例子-MvcDemo2）\n将数据从控制器(Controller)传向视图（View)\n（对应控制器HomeController）\n​ 1.ViewBag 2.ViewData 3.TempData 4.model\n   ViewBag ViewData TempData model     不能跨页面一般存放一些不是主要的数据 不能跨页面一般存放一些不是主要的数据 存储之后，只能读取一次然后就被清空，类似于只能读取一次的Session View方法有多个重载，根据参数不同调用不同方法，参数有viewName视图页名称，masterName布局页名称，model数据模型   ViewBag.MyName = \u0026ldquo;Joe\u0026rdquo;; ViewData[\u0026ldquo;Age\u0026rdquo;] = 30; TempData[\u0026ldquo;Hello\u0026rdquo;] = \u0026ldquo;world\u0026rdquo;;//赋值 View(new Student(){Id = 1,Name=\u0026quot;张三\u0026rdquo;,Age=20})    视图传数据到控制器\n（对应控制器DemoController，对应action：Index()，ShowForm() ）\n   Get Post     action方法接受参数Index(string name) Action方法接受参数Index(string name)   地址栏url加 \u0026ldquo;?name=value\u0026rdquo; Form表单提交   相当于Request.QueryString[\u0026ldquo;name\u0026rdquo;] Request.Form[\u0026ldquo;name\u0026rdquo;]    action方法除了声明各个参数接受请求提交的数据以外，可以直接使用模型。\n如 public ActionResult Login(Models.LoginViewModel model){ }\n只要数据提交的变量名称与模型的属性名称对应就行，这样还能先对上传的数据进行验证，判断数据是否符合模型属性的定义\n通过ViewModel自动生成View页面 （对应控制器DemoController，对应action：Login() ）\n 在Models目录建立LoginViewModel.cs，这是登录所需的数据模型，设置好需要的属性，如name，password； 在DemoController建立Login的action方法，可分成只接受Get请求和只接受Post请求的action方法，共两个Login的action方法； 根据LoginViewMode自动生成view（cshtml页面），在Login方法名上右键，点击添加视图，选择模板（Template）为Create，模型类（Model class）为LoginViewModel，选项（Options）勾选引用脚步库（Reference script libraries）和使用布局页（Use a layout page），点击添加（Add）。  这样生成的view页面会自动拥有模型属性所需数据的form表单，而且会根据模型属性的注解自动验证，根据需要可修改是否必填、显示名称、字符长度、错误信息提醒内容……\n后期，如果模型修改，view页面也可以再重新生成一次。\n注：创建视图view时之所以选择模板（Template）Create，是因为Create模板需要先填写数据再向服务器发送一次请求来创建新记录到数据库，和登录的情况比较类似。\nActionResult下面可用的子类 （对应项目：MvcDemo3，对应控制器HomeController）\nActionResult子类：\n​\tViewResult类——返回相应的视图View\n​\tContentResult类——返回字符串\n​\tRedirectResult类——重定向到url地址 Redirect(\u0026ldquo;http://www.baidu.com\u0026rdquo;);\n​\tRedirectToRouteResult类——根据路由进行重定向 RedirectToAction(\u0026ldquo;参数1-actionName\u0026rdquo;，\u0026ldquo;参数2-controllerName\u0026rdquo;)，如果没有参数2则跳转到当前控制器里面的action。\n​\tFileResult类——向客户端输出文件，File(\u0026ldquo;参数1-文件路径\u0026rdquo;,\u0026ldquo;参数2-文件类型\u0026rdquo;); 有多种重载方发，这个最简单而以。\n​\tJsonResult类——向客户端返回对象的json序列化后的结果\n​\tHttpStatusCodeResult类——显示不同的http状态码信息\n​\tPartialViewResult类——返回 ”部分页面“\nRazor剃须刀 - 网页的模板 （对应项目：MvcDemo3，对应控制器StudentController，对应页面List.cshtml）\nAreas区域 区域可将项目分成不同模块/版块，各个模块自己有路由规则、控制器、视图、模型。\n便于文件结构的管理，避免代码堆积在同一个文件里面。\n区域Area是独立的MVC，拥有独立的路由\n分了区域后的注意问题：\n1、原本项目的路由 和 区域Areas里面的路由，如果有相同的controller名称，则会冲突，可以更改RouteConfig.cs里面的配置，为原来的路由加上namespace参数。\n​\t解决方法：在RouteConfig.cs文件defaults下面添加namespaces（如文件注释）\n2、跨路由跳转，如MvcDemo3里面一共有3个路由，默认1个，Sport1个，Admin1个。自动生成标签。\n​\t解决方法：在页面View里面用这种方式写链接@Html.RouteLink\n​\t不跨路由，Action之间跳转，自动生成标签。\n​\t解决方法：用这种方式写链接@Html.ActionLink\n3、@Url.Action和@Url.RouteUrl不会自动生成标签，但会生成URL地址，第一个方法是生成本路由的路径，第二个方法是生成跨路由的路径。\nEntityFramework Model：用于处理项目的数据模型，处理和数据库相关的事情\nEntityFramework：处理数据和连接数据推荐的方式，包含3中不同实现方式\n​\tDatabase First：\n​\tModel First：\n​\tCode First：代码优先，既可以用于已经存在的数据库连接，也可用于没有数据库要新键数据库\n一、Code First方式：\n使用EntityFramework的Code First模式连接数据库，并在Web.Config配置中添加新的数据库连接字符串，一运行项目当使用到数据库的时候就会在本地文件夹App_Data里面生成一个LocalDB的数据库文件 ”.mdf“\n1、创建model，声明类的属性\n//名为Movie的数据模型 public class Movie{ public int ID {get;set;} public string Title\t{get;set} public DateTime ReleaseDate\t{get;set;} public string Genre {get;set;} public decimal Price {get;set;} }  2、在类的代码块下面接着写一个类并继承DbContext，此类用于CodeFirst方式管理数据库连接\npublic class MovieDBContext : DbContext{ public DbSet\u0026lt;Movie\u0026gt; Movies {get;set;}\t//这也是一个属性 }  3、在Web.config文件里面找到标签，\n在里面添加连接数据库字符串，这里连接的是VisualStudio自带的LocalDB数据库。\n\u0026lt;connectionStrings\u0026gt; \u0026lt;add name=\u0026quot;MovieDBContext\u0026quot; connectionString=\u0026quot;Data Source=(LocalDB)\\v11.0;AttachDbFilename=|DataDirectory|\\Movices.mdf;Integrated Security=True\u0026quot; provideName=\u0026quot;System.Data.SqlClient\u0026quot;/\u0026gt; \u0026lt;/connectionStrings\u0026gt; \u0026lt;!-- 一般配置文件里面已经有一个默认的connectionString，写法可以参考一下 --\u0026gt;  4、添加Controller，并 选择 MVC 5 Controller with views,using Entity Framework，这是自带的一种Scaffold（脚手架，支架），再选择Controller使用的模型类（Movie），以及数据上下文类（MovieDBContext）。这样就会自动创建好具有增删改查功能的网站应用，可以在页面上操作数据。如果要看数据库可以在解决方案资源管理器里面找到App_Data文件夹里面的Movies.mdf，在VS右边有一个叫Server Explorer的窗口，里面有Data Connections目录，目录里面有自动创建好的数据库，名为MovieDBContext。\n","id":4,"section":"posts","summary":"ASP.NET MVC笔记 关于asp.net基础的笔记，对应3个demo，demo里面也有注释，分别是MvcDemo1，MvcDemo2，MvcDemo3","tags":["Asp.Net"],"title":"ASP.NET MVC笔记","uri":"https://joeyang65.github.io/2020/04/asp.net-mvc%E7%AC%94%E8%AE%B0/","year":"2020"}],"tags":[{"title":"Asp.Net","uri":"https://joeyang65.github.io/tags/asp.net/"},{"title":"C#","uri":"https://joeyang65.github.io/tags/c#/"},{"title":"Git","uri":"https://joeyang65.github.io/tags/git/"},{"title":"Markdown","uri":"https://joeyang65.github.io/tags/markdown/"}]}